var rt=Object.defineProperty;var nt=(o,e,t)=>e in o?rt(o,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):o[e]=t;var d=(o,e,t)=>(nt(o,typeof e!="symbol"?e+"":e,t),t),Ge=(o,e,t)=>{if(!e.has(o))throw TypeError("Cannot "+t)};var v=(o,e,t)=>(Ge(o,e,"read from private field"),t?t.call(o):e.get(o)),H=(o,e,t)=>{if(e.has(o))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(o):e.set(o,t)},V=(o,e,t,s)=>(Ge(o,e,"write to private field"),s?s.call(o,t):e.set(o,t),t);import{B as fe,M as re,a as ke,V as U,S as Ve,C as it,T as te,b as ot,I as at,c as lt,d as ut,e as dt,f as Fe,g as ct,h as ft}from"./three@0.169.11.js";import{D as ht,K as gt,M as pt,G as $e}from"./three-examples.8b938a8a.js";const mt="modulepreload",yt=function(o,e){return new URL(o,e).href},Ue={},xt=function(e,t,s){if(!t||t.length===0)return e();const i=document.getElementsByTagName("link");return Promise.all(t.map(r=>{if(r=yt(r,s),r in Ue)return;Ue[r]=!0;const n=r.endsWith(".css"),a=n?'[rel="stylesheet"]':"";if(!!s)for(let c=i.length-1;c>=0;c--){const g=i[c];if(g.href===r&&(!n||g.rel==="stylesheet"))return}else if(document.querySelector(`link[href="${r}"]${a}`))return;const u=document.createElement("link");if(u.rel=n?"stylesheet":mt,n||(u.as="script",u.crossOrigin=""),u.href=r,document.head.appendChild(u),n)return new Promise((c,g)=>{u.addEventListener("load",c),u.addEventListener("error",()=>g(new Error(`Unable to preload CSS for ${r}`)))})})).then(()=>e()).catch(r=>{const n=new Event("vite:preloadError",{cancelable:!0});if(n.payload=r,window.dispatchEvent(n),!n.defaultPrevented)throw r})},Ke="3.3.2";globalThis.GLTF_PROGRESSIVE_VERSION=Ke;console.debug(`[gltf-progressive] version ${Ke}`);let W="https://www.gstatic.com/draco/versioned/decoders/1.5.7/",ne="https://cdn.needle.tools/static/three/0.179.1/basis2/";const wt=W,Lt=ne,Xe=new URL(W+"draco_decoder.js");Xe.searchParams.append("range","true");fetch(Xe,{method:"GET",headers:{Range:"bytes=0-1"}}).catch(o=>{console.debug(`Failed to fetch remote Draco decoder from ${W} (offline: ${typeof navigator<"u"?navigator.onLine:"unknown"})`),W===wt&&Dt("./include/draco/"),ne===Lt&&Mt("./include/ktx2/")}).finally(()=>{je()});const _t=()=>({dracoDecoderPath:W,ktx2TranscoderPath:ne});function Dt(o){W=o,G&&G[Ce]!=W?(console.debug("Updating Draco decoder path to "+o),G[Ce]=W,G.setDecoderPath(W),G.preload()):console.debug("Setting Draco decoder path to "+o)}function Mt(o){ne=o,z&&z.transcoderPath!=ne?(console.debug("Updating KTX2 transcoder path to "+o),z.setTranscoderPath(ne),z.init()):console.debug("Setting KTX2 transcoder path to "+o)}function Re(o){return je(),o?z.detectSupport(o):o!==null&&console.warn("No renderer provided to detect ktx2 support - loading KTX2 textures might fail"),{dracoLoader:G,ktx2Loader:z,meshoptDecoder:Le}}function Ye(o){o.dracoLoader||o.setDRACOLoader(G),o.ktx2Loader||o.setKTX2Loader(z),o.meshoptDecoder||o.setMeshoptDecoder(Le)}const Ce=Symbol("dracoDecoderPath");let G,Le,z;function je(){G||(G=new ht,G[Ce]=W,G.setDecoderPath(W),G.setDecoderConfig({type:"js"}),G.preload()),z||(z=new gt,z.setTranscoderPath(ne),z.init()),Le||(Le=pt)}const Ie=new WeakMap;function He(o,e){let t=Ie.get(o);t?t=Object.assign(t,e):t=e,Ie.set(o,t)}const Oe=$e.prototype.load;function bt(...o){const e=Ie.get(this);let t=o[0];const s=new URL(t,window.location.href);if(s.hostname.endsWith("needle.tools")){const r=(e==null?void 0:e.progressive)!==void 0?e.progressive:!0,n=e!=null&&e.usecase?e.usecase:"default";r?this.requestHeader.Accept=`*/*;progressive=allowed;usecase=${n}`:this.requestHeader.Accept=`*/*;usecase=${n}`,t=s.toString()}return o[0]=t,Oe==null?void 0:Oe.call(this,...o)}$e.prototype.load=bt;ie("debugprogressive");function ie(o){if(typeof window>"u")return!1;const t=new URL(window.location.href).searchParams.get(o);return t==null||t==="0"||t==="false"?!1:t===""?!0:t}function vt(o,e){if(e===void 0||e.startsWith("./")||e.startsWith("http")||o===void 0)return e;const t=o.lastIndexOf("/");if(t>=0){const s=o.substring(0,t+1);for(;s.endsWith("/")&&e.startsWith("/");)e=e.substring(1);return s+e}return e}let le;function Qe(){return le!==void 0||(le=/iPhone|iPad|iPod|Android|IEMobile/i.test(navigator.userAgent),ie("debugprogressive")&&console.log("[glTF Progressive]: isMobileDevice",le)),le}function Ne(){if(typeof window>"u")return!1;const o=new URL(window.location.href),e=o.hostname==="localhost"||/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/.test(o.hostname);return o.hostname==="127.0.0.1"||e}class Ot{constructor(e=100,t={}){d(this,"maxConcurrent");d(this,"_running",new Map);d(this,"_queue",[]);d(this,"debug",!1);d(this,"tick",()=>{this.internalUpdate(),setTimeout(this.tick,10)});this.maxConcurrent=e,this.debug=t.debug??!1,window.requestAnimationFrame(this.tick)}slot(e){return this.debug&&console.debug(`[PromiseQueue]: Requesting slot for key ${e}, running: ${this._running.size}, waiting: ${this._queue.length}`),new Promise(t=>{this._queue.push({key:e,resolve:t})})}add(e,t){this._running.has(e)||(this._running.set(e,t),t.finally(()=>{this._running.delete(e),this.debug&&console.debug(`[PromiseQueue]: Promise finished now running: ${this._running.size}, waiting: ${this._queue.length}. (finished ${e})`)}),this.debug&&console.debug(`[PromiseQueue]: Added new promise, now running: ${this._running.size}, waiting: ${this._queue.length}. (added ${e})`))}internalUpdate(){const e=this.maxConcurrent-this._running.size;for(let t=0;t<e&&this._queue.length>0;t++){this.debug&&console.debug(`[PromiseQueue]: Running ${this._running.size} promises, waiting for ${this._queue.length} more.`);const{key:s,resolve:i}=this._queue.shift();i({use:r=>this.add(s,r)})}}}const St=typeof window>"u"&&typeof document>"u",Be=Symbol("needle:raycast-mesh");function he(o){return(o==null?void 0:o[Be])instanceof fe?o[Be]:null}function Pt(o,e){if((o.type==="Mesh"||o.type==="SkinnedMesh")&&!he(o)){const s=At(e);s.userData={isRaycastMesh:!0},o[Be]=s}}function Tt(o=!0){if(o){if(ue)return;const e=ue=re.prototype.raycast;re.prototype.raycast=function(t,s){const i=this,r=he(i);let n;r&&i.isMesh&&(n=i.geometry,i.geometry=r),e.call(this,t,s),n&&(i.geometry=n)}}else{if(!ue)return;re.prototype.raycast=ue,ue=null}}let ue=null;function At(o){const e=new fe;for(const t in o.attributes)e.setAttribute(t,o.getAttribute(t));return e.setIndex(o.getIndex()),e}const Z=new Array,x=ie("debugprogressive");let xe,se=-1;if(x){let e=function(){se+=1,se>=o&&(se=-1),console.log(`Toggle LOD level [${se}]`)},o=6;window.addEventListener("keyup",t=>{t.key==="p"&&e(),t.key==="w"&&(xe=!xe,console.log(`Toggle wireframe [${xe}]`));const s=parseInt(t.key);!isNaN(s)&&s>=0&&(se=s,console.log(`Set LOD level to [${se}]`))})}function Ze(o){if(x)if(Array.isArray(o))for(const e of o)Ze(e);else o&&"wireframe"in o&&(o.wireframe=xe===!0)}const de=new Array;let kt=0;const Ct=Qe()?2:10;function It(o){if(de.length<Ct){const s=de.length;x&&console.warn(`[Worker] Creating new worker #${s}`);const i=Ee.createWorker(o||{});return de.push(i),i}const e=kt++%de.length;return de[e]}class Ee{constructor(e,t){d(this,"worker");d(this,"_running",[]);d(this,"_webglRenderer",null);d(this,"_debug",!1);this.worker=e,this._debug=t.debug??!1,e.onmessage=s=>{const i=s.data;switch(this._debug&&console.log("[Worker] EVENT",i),i.type){case"loaded-gltf":for(const r of this._running)if(r.url===i.result.url){Bt(i.result),r.resolve(i.result);const n=r.url;n.startsWith("blob:")&&URL.revokeObjectURL(n)}}},e.onerror=s=>{console.error("[Worker] Error in gltf-progressive worker:",s)},e.postMessage({type:"init"})}static async createWorker(e){const t=new Worker(new URL(""+new URL("loader.worker-6e061443.js",import.meta.url).href,self.location),{type:"module"});return new Ee(t,e)}async load(e,t){const s=_t();let i=t==null?void 0:t.renderer;i||(this._webglRenderer??(this._webglRenderer=(async()=>{const{WebGLRenderer:u}=await xt(()=>import("./three@0.169.11.js").then(c=>c.cZ),[],import.meta.url);return new u})()),i=await this._webglRenderer);const a=Re(i).ktx2Loader.workerConfig;e instanceof URL?e=e.toString():e.startsWith("file:")?e=URL.createObjectURL(new Blob([e])):!e.startsWith("blob:")&&!e.startsWith("http:")&&!e.startsWith("https:")&&(e=new URL(e,window.location.href).toString());const l={type:"load",url:e,dracoDecoderPath:s.dracoDecoderPath,ktx2TranscoderPath:s.ktx2TranscoderPath,ktx2LoaderConfig:a};return this._debug&&console.debug("[Worker] Sending load request",l),this.worker.postMessage(l),new Promise(u=>{this._running.push({url:e.toString(),resolve:u})})}}function Bt(o){var e,t,s,i,r,n,a,l,u,c,g,D,w,P,M,I;for(const S of o.geometries){const f=S.geometry,b=new fe;if(b.name=f.name||"",f.index){const h=f.index;b.setIndex(Se(h))}for(const h in f.attributes){const L=f.attributes[h],A=Se(L);b.setAttribute(h,A)}if(f.morphAttributes)for(const h in f.morphAttributes){const A=f.morphAttributes[h].map(F=>Se(F));b.morphAttributes[h]=A}if(b.morphTargetsRelative=f.morphTargetsRelative??!1,b.boundingBox=new ke,b.boundingBox.min=new U((e=f.boundingBox)==null?void 0:e.min.x,(t=f.boundingBox)==null?void 0:t.min.y,(s=f.boundingBox)==null?void 0:s.min.z),b.boundingBox.max=new U((i=f.boundingBox)==null?void 0:i.max.x,(r=f.boundingBox)==null?void 0:r.max.y,(n=f.boundingBox)==null?void 0:n.max.z),b.boundingSphere=new Ve(new U((a=f.boundingSphere)==null?void 0:a.center.x,(l=f.boundingSphere)==null?void 0:l.center.y,(u=f.boundingSphere)==null?void 0:u.center.z),(c=f.boundingSphere)==null?void 0:c.radius),f.groups)for(const h of f.groups)b.addGroup(h.start,h.count,h.materialIndex);f.userData&&(b.userData=f.userData),S.geometry=b}for(const S of o.textures){const f=S.texture;let b=null;if(f.isCompressedTexture){const h=f.mipmaps,L=((g=f.image)==null?void 0:g.width)||((w=(D=f.source)==null?void 0:D.data)==null?void 0:w.width)||-1,A=((P=f.image)==null?void 0:P.height)||((I=(M=f.source)==null?void 0:M.data)==null?void 0:I.height)||-1;b=new it(h,L,A,f.format,f.type,f.mapping,f.wrapS,f.wrapT,f.magFilter,f.minFilter,f.anisotropy,f.colorSpace)}else b=new te(f.image,f.mapping,f.wrapS,f.wrapT,f.magFilter,f.minFilter,f.format,f.type,f.anisotropy,f.colorSpace),b.mipmaps=f.mipmaps,b.channel=f.channel,b.source.data=f.source.data,b.flipY=f.flipY,b.premultiplyAlpha=f.premultiplyAlpha,b.unpackAlignment=f.unpackAlignment,b.matrix=new ot(...f.matrix.elements);if(!b){console.error("[Worker] Failed to create new texture from received data. Texture is not a CompressedTexture or Texture.");continue}S.texture=b}return o}function Se(o){let e=o;if("isInterleavedBufferAttribute"in o&&o.isInterleavedBufferAttribute){const t=o.data,s=t.array,i=new at(s,t.stride);e=new lt(i,o.itemSize,s.byteOffset,o.normalized),e.offset=o.offset}else"isBufferAttribute"in o&&o.isBufferAttribute&&(e=new ut(o.array,o.itemSize,o.normalized),e.usage=o.usage,e.gpuType=o.gpuType,e.updateRanges=o.updateRanges);return e}const $t=ie("gltf-progressive-worker"),Rt=ie("gltf-progressive-reduce-mipmaps"),Pe=Symbol("needle-progressive-texture"),X="NEEDLE_progressive",_=class _{constructor(e){d(this,"parser");d(this,"url");d(this,"_isLoadingMesh");d(this,"loadMesh",e=>{var s,i;if(this._isLoadingMesh)return null;const t=(i=(s=this.parser.json.meshes[e])==null?void 0:s.extensions)==null?void 0:i[X];return t?(this._isLoadingMesh=!0,this.parser.getDependency("mesh",e).then(r=>{var n;return this._isLoadingMesh=!1,r&&_.registerMesh(this.url,t.guid,r,(n=t.lods)==null?void 0:n.length,0,t),r})):null});const t=e.options.path;x&&console.log("Progressive extension registered for",t),this.parser=e,this.url=t}get name(){return X}static getMeshLODExtension(e){const t=this.getAssignedLODInformation(e);return t!=null&&t.key?this.lodInfos.get(t.key):null}static getPrimitiveIndex(e){var s;const t=(s=this.getAssignedLODInformation(e))==null?void 0:s.index;return t??-1}static getMaterialMinMaxLODsCount(e,t){const s=this,i="LODS:minmax",r=e[i];if(r!=null)return r;if(t||(t={min_count:1/0,max_count:0,lods:[]}),Array.isArray(e)){for(const a of e)this.getMaterialMinMaxLODsCount(a,t);return e[i]=t,t}if(x==="verbose"&&console.log("getMaterialMinMaxLODsCount",e),e.type==="ShaderMaterial"||e.type==="RawShaderMaterial"){const a=e;for(const l of Object.keys(a.uniforms)){const u=a.uniforms[l].value;(u==null?void 0:u.isTexture)===!0&&n(u,t)}}else if(e.isMaterial)for(const a of Object.keys(e)){const l=e[a];(l==null?void 0:l.isTexture)===!0&&n(l,t)}else x&&console.warn(`[getMaterialMinMaxLODsCount] Unsupported material type: ${e.type}`);return e[i]=t,t;function n(a,l){const u=s.getAssignedLODInformation(a);if(u){const c=s.lodInfos.get(u.key);if(c&&c.lods){l.min_count=Math.min(l.min_count,c.lods.length),l.max_count=Math.max(l.max_count,c.lods.length);for(let g=0;g<c.lods.length;g++){const D=c.lods[g];D.width&&(l.lods[g]=l.lods[g]||{min_height:1/0,max_height:0},l.lods[g].min_height=Math.min(l.lods[g].min_height,D.height),l.lods[g].max_height=Math.max(l.lods[g].max_height,D.height))}}}}}static hasLODLevelAvailable(e,t){var r;if(Array.isArray(e)){for(const n of e)if(this.hasLODLevelAvailable(n,t))return!0;return!1}if(e.isMaterial===!0){for(const n of Object.keys(e)){const a=e[n];if(a&&a.isTexture&&this.hasLODLevelAvailable(a,t))return!0}return!1}else if(e.isGroup===!0){for(const n of e.children)if(n.isMesh===!0&&this.hasLODLevelAvailable(n,t))return!0}let s,i;if(e.isMesh?s=e.geometry:(e.isBufferGeometry||e.isTexture)&&(s=e),s&&(r=s==null?void 0:s.userData)!=null&&r.LODS){const n=s.userData.LODS;if(i=this.lodInfos.get(n.key),t===void 0)return i!=null;if(i)return Array.isArray(i.lods)?t<i.lods.length:t===0}return!1}static assignMeshLOD(e,t){var s;if(!e)return Promise.resolve(null);if(e instanceof re||e.isMesh===!0){const i=e.geometry,r=this.getAssignedLODInformation(i);if(!r)return Promise.resolve(null);for(const n of Z)(s=n.onBeforeGetLODMesh)==null||s.call(n,e,t);return e["LOD:requested level"]=t,_.getOrLoadLOD(i,t).then(n=>{if(Array.isArray(n)){const a=r.index||0;n=n[a]}return e["LOD:requested level"]===t&&(delete e["LOD:requested level"],n&&i!=n&&((n==null?void 0:n.isBufferGeometry)?e.geometry=n:x&&console.error("Invalid LOD geometry",n))),n}).catch(n=>(console.error("Error loading mesh LOD",e,n),null))}else x&&console.error("Invalid call to assignMeshLOD: Request mesh LOD but the object is not a mesh",e);return Promise.resolve(null)}static assignTextureLOD(e,t=0){if(!e)return Promise.resolve(null);if(e.isMesh===!0){const s=e;if(Array.isArray(s.material)){const i=new Array;for(const r of s.material){const n=this.assignTextureLOD(r,t);i.push(n)}return Promise.all(i).then(r=>{const n=new Array;for(const a of r)Array.isArray(a)&&n.push(...a);return n})}else return this.assignTextureLOD(s.material,t)}if(e.isMaterial===!0){const s=e,i=[],r=new Array;if(s.uniforms&&(s.isRawShaderMaterial||s.isShaderMaterial===!0)){const n=s;for(const a of Object.keys(n.uniforms)){const l=n.uniforms[a].value;if((l==null?void 0:l.isTexture)===!0){const u=this.assignTextureLODForSlot(l,t,s,a).then(c=>(c&&n.uniforms[a].value!=c&&(n.uniforms[a].value=c,n.uniformsNeedUpdate=!0),c));i.push(u),r.push(a)}}}else for(const n of Object.keys(s)){const a=s[n];if((a==null?void 0:a.isTexture)===!0){const l=this.assignTextureLODForSlot(a,t,s,n);i.push(l),r.push(n)}}return Promise.all(i).then(n=>{const a=new Array;for(let l=0;l<n.length;l++){const u=n[l],c=r[l];u&&u.isTexture===!0?a.push({material:s,slot:c,texture:u,level:t}):a.push({material:s,slot:c,texture:null,level:t})}return a})}if(e instanceof te||e.isTexture===!0){const s=e;return this.assignTextureLODForSlot(s,t,null,null)}return Promise.resolve(null)}static assignTextureLODForSlot(e,t,s,i){return(e==null?void 0:e.isTexture)!==!0?Promise.resolve(null):i==="glyphMap"?Promise.resolve(e):_.getOrLoadLOD(e,t).then(r=>{var n,a;if(Array.isArray(r))return console.warn("Progressive: Got an array of textures for a texture slot, this should not happen..."),null;if((r==null?void 0:r.isTexture)===!0){if(r!=e&&s&&i){const l=s[i];if(l&&!x){const u=this.getAssignedLODInformation(l);if(u&&(u==null?void 0:u.level)<t)return x==="verbose"&&console.warn("Assigned texture level is already higher: ",u.level,t,s,l,r),null}if(Rt&&r.mipmaps){const u=r.mipmaps.length;r.mipmaps.length=Math.min(r.mipmaps.length,3),u!==r.mipmaps.length&&x&&console.debug(`Reduced mipmap count from ${u} to ${r.mipmaps.length} for ${r.uuid}: ${(n=r.image)==null?void 0:n.width}x${(a=r.image)==null?void 0:a.height}.`)}s[i]=r}return r}else x=="verbose"&&console.warn("No LOD found for",e,t);return null}).catch(r=>(console.error("Error loading LOD",e,r),null))}afterRoot(e){var t,s;return x&&console.log("AFTER",this.url,e),(t=this.parser.json.textures)==null||t.forEach((i,r)=>{var n;if(i!=null&&i.extensions){const a=i==null?void 0:i.extensions[X];if(a){if(!a.lods){x&&console.warn("Texture has no LODs",a);return}let l=!1;for(const u of this.parser.associations.keys())if(u.isTexture===!0){const c=this.parser.associations.get(u);(c==null?void 0:c.textures)===r&&(l=!0,_.registerTexture(this.url,u,(n=a.lods)==null?void 0:n.length,r,a))}l||this.parser.getDependency("texture",r).then(u=>{var c;u&&_.registerTexture(this.url,u,(c=a.lods)==null?void 0:c.length,r,a)})}}}),(s=this.parser.json.meshes)==null||s.forEach((i,r)=>{if(i!=null&&i.extensions){const n=i==null?void 0:i.extensions[X];if(n&&n.lods){for(const a of this.parser.associations.keys())if(a.isMesh){const l=this.parser.associations.get(a);(l==null?void 0:l.meshes)===r&&_.registerMesh(this.url,n.guid,a,n.lods.length,l.primitives,n)}}}}),null}static async getOrLoadLOD(e,t){var l,u,c,g;const s=x=="verbose",i=this.getAssignedLODInformation(e);if(!i)return x&&console.warn(`[gltf-progressive] No LOD information found: ${e.name}, uuid: ${e.uuid}, type: ${e.type}`,e),null;const r=i==null?void 0:i.key;let n;if(e.isTexture===!0){const D=e;D.source&&D.source[Pe]&&(n=D.source[Pe])}if(n||(n=_.lodInfos.get(r)),n){if(t>0){let P=!1;const M=Array.isArray(n.lods);if(M&&t>=n.lods.length?P=!0:M||(P=!0),P)return this.lowresCache.get(r)}const D=Array.isArray(n.lods)?(l=n.lods[t])==null?void 0:l.path:n.lods;if(!D)return x&&!n["missing:uri"]&&(n["missing:uri"]=!0,console.warn("Missing uri for progressive asset for LOD "+t,n)),null;const w=vt(i.url,D);if(w.endsWith(".glb")||w.endsWith(".gltf")){if(!n.guid)return console.warn("missing pointer for glb/gltf texture",n),null;const P=w+"_"+n.guid,M=await this.queue.slot(w),I=this.previouslyLoaded.get(P);if(I!==void 0){s&&console.log(`LOD ${t} was already loading/loaded: ${P}`);let h=await I.catch(A=>(console.error(`Error loading LOD ${t} from ${w}
`,A),null)),L=!1;if(h==null||(h instanceof te&&e instanceof te?(u=h.image)!=null&&u.data||(c=h.source)!=null&&c.data?h=this.copySettings(e,h):(L=!0,this.previouslyLoaded.delete(P)):h instanceof fe&&e instanceof fe&&((g=h.attributes.position)!=null&&g.array||(L=!0,this.previouslyLoaded.delete(P)))),!L)return h}if(!M.use)return x&&console.log(`LOD ${t} was aborted: ${w}`),null;const S=n,f=new Promise(async(h,L)=>{if($t){const m=await(await It({})).load(w);if(m.textures.length>0)for(const p of m.textures){let y=p.texture;return _.assignLODInformation(i.url,y,r,t,void 0),e instanceof te&&(y=this.copySettings(e,y)),y&&(y.guid=S.guid),h(y)}if(m.geometries.length>0){const p=new Array;for(const y of m.geometries){const C=y.geometry;_.assignLODInformation(i.url,C,r,t,y.primitiveIndex),p.push(C)}return h(p)}return h(null)}const A=new $e;Ye(A),x&&(await new Promise(T=>setTimeout(T,1e3)),s&&console.warn("Start loading (delayed) "+w,S.guid));let F=w;if(S&&Array.isArray(S.lods)){const T=S.lods[t];T.hash&&(F+="?v="+T.hash)}const k=await A.loadAsync(F).catch(T=>(console.error(`Error loading LOD ${t} from ${w}
`,T),h(null)));if(!k)return h(null);const ee=k.parser;s&&console.log("Loading finished "+w,S.guid);let $=0;if(k.parser.json.textures){let T=!1;for(const m of k.parser.json.textures){if(m!=null&&m.extensions){const p=m==null?void 0:m.extensions[X];if(p!=null&&p.guid&&p.guid===S.guid){T=!0;break}}$++}if(T){let m=await ee.getDependency("texture",$);return m&&_.assignLODInformation(i.url,m,r,t,void 0),s&&console.log('change "'+e.name+'" → "'+m.name+'"',w,$,m,P),e instanceof te&&(m=this.copySettings(e,m)),m&&(m.guid=S.guid),h(m)}else x&&console.warn("Could not find texture with guid",S.guid,k.parser.json)}if($=0,k.parser.json.meshes){let T=!1;for(const m of k.parser.json.meshes){if(m!=null&&m.extensions){const p=m==null?void 0:m.extensions[X];if(p!=null&&p.guid&&p.guid===S.guid){T=!0;break}}$++}if(T){const m=await ee.getDependency("mesh",$);if(s&&console.log(`Loaded Mesh "${m.name}"`,w,$,m,P),m.isMesh===!0){const p=m.geometry;return _.assignLODInformation(i.url,p,r,t,0),h(p)}else{const p=new Array;for(let y=0;y<m.children.length;y++){const C=m.children[y];if(C.isMesh===!0){const B=C.geometry;_.assignLODInformation(i.url,B,r,t,y),p.push(B)}}return h(p)}}else x&&console.warn("Could not find mesh with guid",S.guid,k.parser.json)}return h(null)});return this.previouslyLoaded.set(P,f),M.use(f),await f}else if(e instanceof te){s&&console.log("Load texture from uri: "+w);const M=await new dt().loadAsync(w);return M?(M.guid=n.guid,M.flipY=!1,M.needsUpdate=!0,M.colorSpace=e.colorSpace,s&&console.log(n,M)):x&&console.warn("failed loading",w),M}}else x&&console.warn(`Can not load LOD ${t}: no LOD info found for "${r}" ${e.name}`,e.type);return null}static assignLODInformation(e,t,s,i,r){if(!t)return;t.userData||(t.userData={});const n=new Et(e,s,i,r);t.userData.LODS=n,"source"in t&&typeof t.source=="object"&&(t.source.LODS=n)}static getAssignedLODInformation(e){var t,s;return e?(t=e.userData)!=null&&t.LODS?e.userData.LODS:"source"in e&&((s=e.source)!=null&&s.LODS)?e.source.LODS:null:null}static copySettings(e,t){return t?(x==="verbose"&&console.debug(`Copy texture settings
`,e.uuid,`
`,t.uuid),t=t.clone(),t.offset=e.offset,t.repeat=e.repeat,t.colorSpace=e.colorSpace,t.magFilter=e.magFilter,t.minFilter=e.minFilter,t.wrapS=e.wrapS,t.wrapT=e.wrapT,t.flipY=e.flipY,t.anisotropy=e.anisotropy,t.mipmaps||(t.generateMipmaps=e.generateMipmaps),t):e}};d(_,"registerTexture",(e,t,s,i,r)=>{var a,l,u,c,g,D,w,P;if(!t){x&&console.error("gltf-progressive: Called register texture without texture");return}if(x){const M=((a=t.image)==null?void 0:a.width)||((u=(l=t.source)==null?void 0:l.data)==null?void 0:u.width)||0,I=((c=t.image)==null?void 0:c.height)||((D=(g=t.source)==null?void 0:g.data)==null?void 0:D.height)||0;console.log(`> Progressive: register texture[${i}] "${t.name||t.uuid}", Current: ${M}x${I}, Max: ${(w=r.lods[0])==null?void 0:w.width}x${(P=r.lods[0])==null?void 0:P.height}, uuid: ${t.uuid}`,r,t)}t.source&&(t.source[Pe]=r);const n=r.guid;_.assignLODInformation(e,t,n,s,i),_.lodInfos.set(n,r),_.lowresCache.set(n,t)}),d(_,"registerMesh",(e,t,s,i,r,n)=>{var u;const a=s.geometry;if(!a){x&&console.warn("gltf-progressive: Register mesh without geometry");return}a.userData||(a.userData={}),x&&console.log("> Progressive: register mesh "+s.name,{index:r,uuid:s.uuid},n,s),_.assignLODInformation(e,a,t,i,r),_.lodInfos.set(t,n);let l=_.lowresCache.get(t);l?l.push(s.geometry):l=[s.geometry],_.lowresCache.set(t,l),i>0&&!he(s)&&Pt(s,a);for(const c of Z)(u=c.onRegisteredNewMesh)==null||u.call(c,s,n)}),d(_,"lodInfos",new Map),d(_,"previouslyLoaded",new Map),d(_,"lowresCache",new Map),d(_,"workers",[]),d(_,"_workersIndex",0),d(_,"maxConcurrent",50),d(_,"queue",new Ot(_.maxConcurrent,{debug:x!=!1}));let K=_;class Et{constructor(e,t,s,i){d(this,"url");d(this,"key");d(this,"level");d(this,"index");this.url=e,this.key=t,this.level=s,i!=null&&(this.index=i)}}class we{constructor(e,t){d(this,"ready");d(this,"_resolve");d(this,"_signal");d(this,"_frame_start");d(this,"_frames_to_capture");d(this,"_resolved",!1);d(this,"_addedCount",0);d(this,"_resolvedCount",0);d(this,"_awaiting",[]);d(this,"_maxPromisesPerObject",1);d(this,"_currentFrame",0);d(this,"_seen",new WeakMap);var r;const i=Math.max(t.frames??2,2);this._frame_start=t.waitForFirstCapture?void 0:e,this._frames_to_capture=i,this.ready=new Promise(n=>{this._resolve=n}),this.ready.finally(()=>{this._resolved=!0,this._awaiting.length=0}),this._signal=t.signal,(r=this._signal)==null||r.addEventListener("abort",()=>{this.resolveNow()}),this._maxPromisesPerObject=Math.max(1,t.maxPromisesPerObject??1)}get awaitedCount(){return this._addedCount}get resolvedCount(){return this._resolvedCount}get currentlyAwaiting(){return this._awaiting.length}update(e){var t;this._currentFrame=e,this._frame_start===void 0&&this._addedCount>0&&(this._frame_start=e),((t=this._signal)!=null&&t.aborted||this._awaiting.length===0&&this._frame_start!==void 0&&e>this._frame_start+this._frames_to_capture)&&this.resolveNow()}add(e,t,s){if(this._resolved){x&&console.warn("PromiseGroup: Trying to add a promise to a resolved group, ignoring.");return}if(!(this._frame_start!==void 0&&this._currentFrame>this._frame_start+this._frames_to_capture)){if(this._maxPromisesPerObject>=1)if(this._seen.has(t)){let i=this._seen.get(t);if(i>=this._maxPromisesPerObject){x&&console.warn("PromiseGroup: Already awaiting object ignoring new promise for it.");return}this._seen.set(t,i+1)}else this._seen.set(t,1);this._awaiting.push(s),this._addedCount++,s.finally(()=>{this._resolvedCount++,this._awaiting.splice(this._awaiting.indexOf(s),1)})}}resolveNow(){var e,t;this._resolved||(t=this._resolve)==null||t.call(this,{awaited_count:this._addedCount,resolved_count:this._resolvedCount,cancelled:((e=this._signal)==null?void 0:e.aborted)??!1})}}d(we,"addPromise",(e,t,s,i)=>{i.forEach(r=>{r.add(e,t,s)})});const N=ie("debugprogressive"),Gt=ie("noprogressive"),Te=Symbol("Needle:LODSManager"),Ae=Symbol("Needle:LODState"),Q=Symbol("Needle:CurrentLOD"),R={mesh_lod:-1,texture_lod:-1};var O,E,Y,De,J,oe,Me,j;let _e=(O=class{constructor(e,t){d(this,"renderer");d(this,"context");d(this,"projectionScreenMatrix",new Fe);d(this,"overrideLodLevel");d(this,"targetTriangleDensity",2e5);d(this,"skinnedMeshAutoUpdateBoundsInterval",30);d(this,"updateInterval","auto");H(this,E,1);d(this,"pause",!1);d(this,"manual",!1);d(this,"_newPromiseGroups",[]);d(this,"_promiseGroupIds",0);d(this,"_lodchangedlisteners",[]);H(this,Y,void 0);H(this,De,new ct);H(this,J,0);H(this,oe,0);H(this,Me,0);H(this,j,0);d(this,"_fpsBuffer",[60,60,60,60,60]);d(this,"_sphere",new Ve);d(this,"_tempBox",new ke);d(this,"_tempBox2",new ke);d(this,"tempMatrix",new Fe);d(this,"_tempWorldPosition",new U);d(this,"_tempBoxSize",new U);d(this,"_tempBox2Size",new U);this.renderer=e,this.context={...t}}static getObjectLODState(e){return e[Ae]}static addPlugin(e){Z.push(e)}static removePlugin(e){const t=Z.indexOf(e);t>=0&&Z.splice(t,1)}static get(e,t){if(e[Te])return console.debug("[gltf-progressive] LODsManager already exists for this renderer"),e[Te];const s=new O(e,{engine:"unknown",...t});return e[Te]=s,s}get plugins(){return Z}awaitLoading(e){const t=this._promiseGroupIds++,s=new we(v(this,J),{...e});this._newPromiseGroups.push(s);const i=performance.now();return s.ready.finally(()=>{const r=this._newPromiseGroups.indexOf(s);r>=0&&(this._newPromiseGroups.splice(r,1),Ne()&&performance.measure("LODsManager:awaitLoading",{start:i,detail:{id:t,name:e==null?void 0:e.name,awaited:s.awaitedCount,resolved:s.resolvedCount}}))}),s.ready}_postprocessPromiseGroups(){if(this._newPromiseGroups.length!==0)for(let e=this._newPromiseGroups.length-1;e>=0;e--)this._newPromiseGroups[e].update(v(this,J))}addEventListener(e,t){e==="changed"&&this._lodchangedlisteners.push(t)}removeEventListener(e,t){if(e==="changed"){const s=this._lodchangedlisteners.indexOf(t);s>=0&&this._lodchangedlisteners.splice(s,1)}}enable(){if(v(this,Y))return;console.debug("[gltf-progressive] Enabling LODsManager for renderer");let e=0;V(this,Y,this.renderer.render);const t=this;Re(this.renderer),this.renderer.render=function(s,i){const r=t.renderer.getRenderTarget();(r==null||"isXRRenderTarget"in r&&r.isXRRenderTarget)&&(e=0,V(t,J,v(t,J)+1),V(t,oe,v(t,De).getDelta()),V(t,Me,v(t,Me)+v(t,oe)),t._fpsBuffer.shift(),t._fpsBuffer.push(1/v(t,oe)),V(t,j,t._fpsBuffer.reduce((a,l)=>a+l)/t._fpsBuffer.length),N&&v(t,J)%200===0&&console.log("FPS",Math.round(v(t,j)),"Interval:",v(t,E)));const n=e++;v(t,Y).call(this,s,i),t.onAfterRender(s,i,n)}}disable(){v(this,Y)&&(console.debug("[gltf-progressive] Disabling LODsManager for renderer"),this.renderer.render=v(this,Y),V(this,Y,void 0))}update(e,t){this.internalUpdate(e,t)}onAfterRender(e,t,s){if(this.pause)return;const r=this.renderer.renderLists.get(e,0).opaque;let n=!0;if(r.length===1){const a=r[0].material;(a.name==="EffectMaterial"||a.name==="CopyShader")&&(n=!1)}if((t.parent&&t.parent.type==="CubeCamera"||s>=1&&t.type==="OrthographicCamera")&&(n=!1),n){if(Gt||(this.updateInterval==="auto"?v(this,j)<40&&v(this,E)<10?(V(this,E,v(this,E)+1),N&&console.warn("↓ Reducing LOD updates",v(this,E),v(this,j).toFixed(0))):v(this,j)>=60&&v(this,E)>1&&(V(this,E,v(this,E)-1),N&&console.warn("↑ Increasing LOD updates",v(this,E),v(this,j).toFixed(0))):V(this,E,this.updateInterval),v(this,E)>0&&v(this,J)%v(this,E)!=0))return;this.internalUpdate(e,t),this._postprocessPromiseGroups()}}internalUpdate(e,t){var l,u;const s=this.renderer.renderLists.get(e,0),i=s.opaque;this.projectionScreenMatrix.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse);const r=this.targetTriangleDensity;for(const c of i){if(c.material&&(((l=c.geometry)==null?void 0:l.type)==="BoxGeometry"||((u=c.geometry)==null?void 0:u.type)==="BufferGeometry")&&(c.material.name==="SphericalGaussianBlur"||c.material.name=="BackgroundCubeMaterial"||c.material.name==="CubemapFromEquirect"||c.material.name==="EquirectangularToCubeUV")){N&&(c.material["NEEDLE_PROGRESSIVE:IGNORE-WARNING"]||(c.material["NEEDLE_PROGRESSIVE:IGNORE-WARNING"]=!0,console.warn("Ignoring skybox or BLIT object",c,c.material.name,c.material.type)));continue}switch(c.material.type){case"LineBasicMaterial":case"LineDashedMaterial":case"PointsMaterial":case"ShadowMaterial":case"MeshDistanceMaterial":case"MeshDepthMaterial":continue}if(N==="color"&&c.material&&!c.object.progressive_debug_color){c.object.progressive_debug_color=!0;const D=Math.random()*16777215,w=new ft({color:D});c.object.material=w}const g=c.object;(g instanceof re||g.isMesh)&&this.updateLODs(e,t,g,r)}const n=s.transparent;for(const c of n){const g=c.object;(g instanceof re||g.isMesh)&&this.updateLODs(e,t,g,r)}const a=s.transmissive;for(const c of a){const g=c.object;(g instanceof re||g.isMesh)&&this.updateLODs(e,t,g,r)}}updateLODs(e,t,s,i){var a,l;s.userData||(s.userData={});let r=s[Ae];if(r||(r=new Ft,s[Ae]=r),r.frames++<2)return;for(const u of Z)(a=u.onBeforeUpdateLOD)==null||a.call(u,this.renderer,e,t,s);const n=this.overrideLodLevel!==void 0?this.overrideLodLevel:se;n>=0?(R.mesh_lod=n,R.texture_lod=n):(this.calculateLodLevel(t,s,r,i,R),R.mesh_lod=Math.round(R.mesh_lod),R.texture_lod=Math.round(R.texture_lod)),R.mesh_lod>=0&&this.loadProgressiveMeshes(s,R.mesh_lod),s.material&&R.texture_lod>=0&&this.loadProgressiveTextures(s.material,R.texture_lod,n),x&&s.material&&!s.isGizmo&&Ze(s.material);for(const u of Z)(l=u.onAfterUpdatedLOD)==null||l.call(u,this.renderer,e,t,s,R);r.lastLodLevel_Mesh=R.mesh_lod,r.lastLodLevel_Texture=R.texture_lod}loadProgressiveTextures(e,t,s){if(!e)return;if(Array.isArray(e)){for(const r of e)this.loadProgressiveTextures(r,t);return}let i=!1;if((e[Q]===void 0||t<e[Q])&&(i=!0),s!==void 0&&s>=0&&(i=e[Q]!=s,t=s),i){e[Q]=t;const r=K.assignTextureLOD(e,t).then(n=>{this._lodchangedlisteners.forEach(a=>a({type:"texture",level:t,object:e}))});we.addPromise("texture",e,r,this._newPromiseGroups)}}loadProgressiveMeshes(e,t){if(!e)return Promise.resolve(null);let s=e[Q]!==t;const i=e["DEBUG:LOD"];if(i!=null&&(s=e[Q]!=i,t=i),s){e[Q]=t;const r=e.geometry,n=K.assignMeshLOD(e,t).then(a=>(a&&e[Q]==t&&r!=e.geometry&&this._lodchangedlisteners.forEach(l=>l({type:"mesh",level:t,object:e})),a));return we.addPromise("mesh",e,n,this._newPromiseGroups),n}return Promise.resolve(null)}static isInside(e,t){const s=e.min,i=e.max,r=(s.x+i.x)*.5,n=(s.y+i.y)*.5;return this._tempPtInside.set(r,n,s.z).applyMatrix4(t).z<0}calculateLodLevel(e,t,s,i,r){var I,S,f,b;if(!t){r.mesh_lod=-1,r.texture_lod=-1;return}if(!e){r.mesh_lod=-1,r.texture_lod=-1;return}let a=10+1,l=!1;if(N&&t["DEBUG:LOD"]!=null)return t["DEBUG:LOD"];const u=(I=K.getMeshLODExtension(t.geometry))==null?void 0:I.lods,c=K.getPrimitiveIndex(t.geometry),g=u&&u.length>0,D=K.getMaterialMinMaxLODsCount(t.material),w=D.min_count!==1/0&&D.min_count>=0&&D.max_count>=0;if(!g&&!w){r.mesh_lod=0,r.texture_lod=0;return}g||(l=!0,a=0);const P=this.renderer.domElement.clientHeight||this.renderer.domElement.height;let M=t.geometry.boundingBox;if(t.type==="SkinnedMesh"){const h=t;if(!h.boundingBox)h.computeBoundingBox();else if(this.skinnedMeshAutoUpdateBoundsInterval>0){if(!h[O.$skinnedMeshBoundsOffset]){const A=O.skinnedMeshBoundsFrameOffsetCounter++;h[O.$skinnedMeshBoundsOffset]=A}const L=h[O.$skinnedMeshBoundsOffset];if((s.frames+L)%this.skinnedMeshAutoUpdateBoundsInterval===0){const A=he(h),F=h.geometry;A&&(h.geometry=A),h.computeBoundingBox(),h.geometry=F}}M=h.boundingBox}if(M){const h=e;if(t.geometry.attributes.color&&t.geometry.attributes.color.count<100&&t.geometry.boundingSphere){this._sphere.copy(t.geometry.boundingSphere),this._sphere.applyMatrix4(t.matrixWorld);const p=e.getWorldPosition(this._tempWorldPosition);if(this._sphere.containsPoint(p)){r.mesh_lod=0,r.texture_lod=0;return}}if(this._tempBox.copy(M),this._tempBox.applyMatrix4(t.matrixWorld),h.isPerspectiveCamera&&O.isInside(this._tempBox,this.projectionScreenMatrix)){r.mesh_lod=0,r.texture_lod=0;return}if(this._tempBox.applyMatrix4(this.projectionScreenMatrix),this.renderer.xr.enabled&&h.isPerspectiveCamera&&h.fov>70){const p=this._tempBox.min,y=this._tempBox.max;let C=p.x,B=p.y,q=y.x,ae=y.y;const ge=2,be=1.5,pe=(p.x+y.x)*.5,me=(p.y+y.y)*.5;C=(C-pe)*ge+pe,B=(B-me)*ge+me,q=(q-pe)*ge+pe,ae=(ae-me)*ge+me;const tt=C<0&&q>0?0:Math.min(Math.abs(p.x),Math.abs(y.x)),st=B<0&&ae>0?0:Math.min(Math.abs(p.y),Math.abs(y.y)),ve=Math.max(tt,st);s.lastCentrality=(be-ve)*(be-ve)*(be-ve)}else s.lastCentrality=1;const L=this._tempBox.getSize(this._tempBoxSize);L.multiplyScalar(.5),screen.availHeight>0&&P>0&&L.multiplyScalar(P/screen.availHeight),e.isPerspectiveCamera?L.x*=e.aspect:e.isOrthographicCamera;const A=e.matrixWorldInverse,F=this._tempBox2;F.copy(M),F.applyMatrix4(t.matrixWorld),F.applyMatrix4(A);const k=F.getSize(this._tempBox2Size),ee=Math.max(k.x,k.y);if(Math.max(L.x,L.y)!=0&&ee!=0&&(L.z=k.z/Math.max(k.x,k.y)*Math.max(L.x,L.y)),s.lastScreenCoverage=Math.max(L.x,L.y,L.z),s.lastScreenspaceVolume.copy(L),s.lastScreenCoverage*=s.lastCentrality,N&&O.debugDrawLine){const p=this.tempMatrix.copy(this.projectionScreenMatrix);p.invert();const y=O.corner0,C=O.corner1,B=O.corner2,q=O.corner3;y.copy(this._tempBox.min),C.copy(this._tempBox.max),C.x=y.x,B.copy(this._tempBox.max),B.y=y.y,q.copy(this._tempBox.max);const ae=(y.z+q.z)*.5;y.z=C.z=B.z=q.z=ae,y.applyMatrix4(p),C.applyMatrix4(p),B.applyMatrix4(p),q.applyMatrix4(p),O.debugDrawLine(y,C,255),O.debugDrawLine(y,B,255),O.debugDrawLine(C,q,255),O.debugDrawLine(B,q,255)}let T=999;if(u&&s.lastScreenCoverage>0)for(let p=0;p<u.length;p++){const y=u[p],B=(((S=y.densities)==null?void 0:S[c])||y.density||1e-5)/s.lastScreenCoverage;if(c>0&&Ne()&&!y.densities&&!globalThis["NEEDLE:MISSING_LOD_PRIMITIVE_DENSITIES"]&&(window["NEEDLE:MISSING_LOD_PRIMITIVE_DENSITIES"]=!0,console.warn("[Needle Progressive] Detected usage of mesh without primitive densities. This might cause incorrect LOD level selection: Consider re-optimizing your model by updating your Needle Integration, Needle glTF Pipeline or running optimization again on Needle Cloud.")),B<i){T=p;break}}T<a&&(a=T,l=!0)}if(l?r.mesh_lod=a:r.mesh_lod=s.lastLodLevel_Mesh,N&&r.mesh_lod!=s.lastLodLevel_Mesh){const L=u==null?void 0:u[r.mesh_lod];L&&console.debug(`Mesh LOD changed: ${s.lastLodLevel_Mesh} → ${r.mesh_lod} (density: ${(f=L.densities)==null?void 0:f[c].toFixed(0)}) | ${t.name}`)}if(w){const h="saveData"in globalThis.navigator&&globalThis.navigator.saveData===!0;if(s.lastLodLevel_Texture<0){if(r.texture_lod=D.max_count-1,N){const L=D.lods[D.max_count-1];N&&console.log(`First Texture LOD ${r.texture_lod} (${L.max_height}px) - ${t.name}`)}}else{const L=s.lastScreenspaceVolume.x+s.lastScreenspaceVolume.y+s.lastScreenspaceVolume.z;let A=s.lastScreenCoverage*4;((b=this.context)==null?void 0:b.engine)==="model-viewer"&&(A*=1.5);const k=P/window.devicePixelRatio*A;let ee=!1;for(let $=D.lods.length-1;$>=0;$--){const T=D.lods[$];if(!(h&&T.max_height>=2048)&&!(Qe()&&T.max_height>4096)&&(T.max_height>k||!ee&&$===0)){if(ee=!0,r.texture_lod=$,N&&r.texture_lod<s.lastLodLevel_Texture){const m=T.max_height;console.log(`Texture LOD changed: ${s.lastLodLevel_Texture} → ${r.texture_lod} = ${m}px 
Screensize: ${k.toFixed(0)}px, Coverage: ${(100*s.lastScreenCoverage).toFixed(2)}%, Volume ${L.toFixed(1)} 
${t.name}`)}break}}}}else r.texture_lod=0}},E=new WeakMap,Y=new WeakMap,De=new WeakMap,J=new WeakMap,oe=new WeakMap,Me=new WeakMap,j=new WeakMap,d(O,"debugDrawLine"),d(O,"corner0",new U),d(O,"corner1",new U),d(O,"corner2",new U),d(O,"corner3",new U),d(O,"_tempPtInside",new U),d(O,"skinnedMeshBoundsFrameOffsetCounter",0),d(O,"$skinnedMeshBoundsOffset",Symbol("gltf-progressive-skinnedMeshBoundsOffset")),O);class Ft{constructor(){d(this,"frames",0);d(this,"lastLodLevel_Mesh",-1);d(this,"lastLodLevel_Texture",-1);d(this,"lastScreenCoverage",0);d(this,"lastScreenspaceVolume",new U);d(this,"lastCentrality",0)}}const We=Symbol("NEEDLE_mesh_lod"),ye=Symbol("NEEDLE_texture_lod");let ce=null;function Je(){const o=Ut();o&&(o.mapURLs(function(e){return ze(),e}),ze(),ce==null||ce.disconnect(),ce=new MutationObserver(e=>{e.forEach(t=>{t.addedNodes.forEach(s=>{s instanceof HTMLElement&&s.tagName.toLowerCase()==="model-viewer"&&et(s)})})}),ce.observe(document,{childList:!0,subtree:!0}))}function Ut(){if(typeof customElements>"u")return null;const o=customElements.get("model-viewer");return o||(customElements.whenDefined("model-viewer").then(()=>{console.debug("[gltf-progressive] model-viewer defined"),Je()}),null)}function ze(){if(typeof document>"u")return;document.querySelectorAll("model-viewer").forEach(e=>{et(e)})}const qe=new WeakSet;let Nt=0;function et(o){if(!o||qe.has(o))return null;qe.add(o),console.debug("[gltf-progressive] found new model-viewer..."+ ++Nt+`
`,o.getAttribute("src"));let e=null,t=null,s=null;for(let i=o;i!=null;i=Object.getPrototypeOf(i)){const r=Object.getOwnPropertySymbols(i),n=r.find(u=>u.toString()=="Symbol(renderer)"),a=r.find(u=>u.toString()=="Symbol(scene)"),l=r.find(u=>u.toString()=="Symbol(needsRender)");!e&&n!=null&&(e=o[n].threeRenderer),!t&&a!=null&&(t=o[a]),!s&&l!=null&&(s=o[l])}if(e&&t){let r=function(){if(s){let n=0,a=setInterval(()=>{if(n++>5){clearInterval(a);return}s==null||s.call(o)},300)}};console.debug("[gltf-progressive] setup model-viewer");const i=_e.get(e,{engine:"model-viewer"});return _e.addPlugin(new Wt),i.enable(),i.addEventListener("changed",()=>{s==null||s.call(o)}),o.addEventListener("model-visibility",n=>{n.detail.visible&&(s==null||s.call(o))}),o.addEventListener("load",()=>{r()}),()=>{i.disable()}}return null}class Wt{constructor(){d(this,"_didWarnAboutMissingUrl",!1)}onBeforeUpdateLOD(e,t,s,i){this.tryParseMeshLOD(t,i),this.tryParseTextureLOD(t,i)}getUrl(e){if(!e)return null;let t=e.getAttribute("src");return t||(t=e.src),t||(this._didWarnAboutMissingUrl||console.warn("No url found in modelviewer",e),this._didWarnAboutMissingUrl=!0),t}tryGetCurrentGLTF(e){return e._currentGLTF}tryGetCurrentModelViewer(e){return e.element}tryParseTextureLOD(e,t){if(t[ye]==!0)return;t[ye]=!0;const s=this.tryGetCurrentGLTF(e),i=this.tryGetCurrentModelViewer(e),r=this.getUrl(i);if(r&&s&&t.material){let a=function(l){var c,g,D;if(l[ye]==!0)return;l[ye]=!0,l.userData&&(l.userData.LOD=-1);const u=Object.keys(l);for(let w=0;w<u.length;w++){const P=u[w],M=l[P];if((M==null?void 0:M.isTexture)===!0){const I=(g=(c=M.userData)==null?void 0:c.associations)==null?void 0:g.textures;if(I==null)continue;const S=s.parser.json.textures[I];if(!S){console.warn("Texture data not found for texture index "+I);continue}if((D=S==null?void 0:S.extensions)!=null&&D[X]){const f=S.extensions[X];f&&r&&K.registerTexture(r,M,f.lods.length,I,f)}}}};const n=t.material;if(Array.isArray(n))for(const l of n)a(l);else a(n)}}tryParseMeshLOD(e,t){var n,a;if(t[We]==!0)return;t[We]=!0;const s=this.tryGetCurrentModelViewer(e),i=this.getUrl(s);if(!i)return;const r=(a=(n=t.userData)==null?void 0:n.gltfExtensions)==null?void 0:a[X];if(r&&i){const l=t.uuid;K.registerMesh(i,l,t,0,r.lods.length,r)}}}function zt(...o){let e,t,s,i;switch(o.length){case 2:[s,t]=o,i={};break;case 3:[s,t,i]=o;break;case 4:[e,t,s,i]=o;break;default:throw new Error("Invalid arguments")}Re(t),Ye(s),He(s,{progressive:!0,...i==null?void 0:i.hints}),s.register(n=>new K(n));const r=_e.get(t);return(i==null?void 0:i.enableLODsManager)!==!1&&r.enable(),r}Je();if(!St){const o={gltfProgressive:{useNeedleProgressive:zt,LODsManager:_e,configureLoader:He,getRaycastMesh:he,useRaycastMeshes:Tt}};if(!globalThis.Needle)globalThis.Needle=o;else for(const e in o)globalThis.Needle[e]=o[e]}export{_e as L,K as N,xt as _,Mt as a,Ye as b,Re as c,He as d,he as g,Dt as s};
